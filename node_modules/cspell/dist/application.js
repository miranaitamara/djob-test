"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._testing_ = exports.createInit = exports.checkText = exports.trace = exports.lint = exports.CSpellApplicationConfiguration = exports.IncludeExcludeFlag = void 0;
const glob_1 = require("./util/glob");
const cspell = __importStar(require("cspell-lib"));
const fsp = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const commentJson = __importStar(require("comment-json"));
const util = __importStar(require("./util/util"));
const cspell_lib_1 = require("cspell-lib");
const get_stdin_1 = __importDefault(require("get-stdin"));
var cspell_lib_2 = require("cspell-lib");
Object.defineProperty(exports, "IncludeExcludeFlag", { enumerable: true, get: function () { return cspell_lib_2.IncludeExcludeFlag; } });
const timer_1 = require("./util/timer");
const emitters_1 = require("./emitters");
// cspell:word nocase
const UTF8 = 'utf8';
const STDIN = 'stdin';
const defaultContextRange = 20;
const defaultMinimatchOptions = { nocase: true };
const defaultConfigGlobOptions = defaultMinimatchOptions;
const nullEmitter = () => {
    /* empty */
};
class CSpellApplicationConfiguration {
    constructor(files, options, emitters) {
        this.files = files;
        this.options = options;
        this.emitters = emitters;
        this.configGlobOptions = defaultConfigGlobOptions;
        this.root = path.resolve(options.root || process.cwd());
        this.info = emitters.info || nullEmitter;
        this.debug = emitters.debug || ((msg) => this.info(msg, emitters_1.MessageTypes.Debug));
        this.configFile = options.config;
        this.excludes = glob_1.calcExcludeGlobInfo(this.root, options.exclude);
        this.logIssue = emitters.issue || nullEmitter;
        this.locale = options.locale || options.local || '';
        this.uniqueFilter = options.unique ? util.uniqueFilterFnGenerator((issue) => issue.text) : () => true;
        this.progress = emitters.progress || nullEmitter;
        this.showContext =
            options.showContext === true ? defaultContextRange : options.showContext ? options.showContext : 0;
    }
}
exports.CSpellApplicationConfiguration = CSpellApplicationConfiguration;
function lint(files, options, emitters) {
    const cfg = new CSpellApplicationConfiguration(files, options, emitters);
    return runLint(cfg);
}
exports.lint = lint;
function runLint(cfg) {
    const configErrors = new Set();
    return run();
    async function processFile(fileInfo, configInfo) {
        const settingsFromCommandLine = util.clean({
            languageId: cfg.options.languageId || undefined,
            language: cfg.locale || undefined,
        });
        const result = {
            fileInfo,
            issues: [],
            processed: false,
            errors: 0,
            configErrors: 0,
            elapsedTimeMs: 0,
        };
        const { filename, text } = fileInfo;
        const info = calcFinalConfigInfo(configInfo, settingsFromCommandLine, filename, text);
        const config = info.configInfo.config;
        const source = info.configInfo.source;
        cfg.debug(`Filename: ${filename}, Extension: ${path.extname(filename)}, LanguageIds: ${info.languageIds.toString()}`);
        if (!info.configInfo.config.enabled)
            return result;
        result.configErrors += await reportConfigurationErrors(info.configInfo.config);
        const debugCfg = { config: { ...config, source: null }, source };
        cfg.debug(commentJson.stringify(debugCfg, undefined, 2));
        const startTime = Date.now();
        try {
            const validateOptions = { generateSuggestions: cfg.options.showSuggestions, numSuggestions: 5 };
            const wordOffsets = await cspell.validateText(text, info.configInfo.config, validateOptions);
            result.processed = true;
            result.issues = cspell.Text.calculateTextDocumentOffsets(filename, text, wordOffsets).map(mapIssue);
        }
        catch (e) {
            cfg.emitters.error(`Failed to process "${filename}"`, e);
            result.errors += 1;
        }
        result.elapsedTimeMs = Date.now() - startTime;
        const elapsed = result.elapsedTimeMs / 1000.0;
        const dictionaries = config.dictionaries || [];
        cfg.info(`Checking: ${filename}, File type: ${config.languageId}, Language: ${config.language} ... Issues: ${result.issues.length} ${elapsed}S`, emitters_1.MessageTypes.Info);
        cfg.info(`Dictionaries Used: ${dictionaries.join(', ')}`, emitters_1.MessageTypes.Info);
        result.issues.filter(cfg.uniqueFilter).forEach((issue) => cfg.logIssue(issue));
        return result;
    }
    function mapIssue(tdo) {
        const context = cfg.showContext
            ? extractContext(tdo, cfg.showContext)
            : { text: tdo.line.text.trimEnd(), offset: tdo.line.offset };
        return { ...tdo, context };
    }
    /**
     * The file loader is written this way to cause files to be loaded in parallel while the previous one is being processed.
     * @param fileNames names of files to load one at a time.
     */
    function* fileLoader(fileNames) {
        for (const filename of fileNames) {
            const file = readFileInfo(filename);
            yield file;
        }
    }
    async function processFiles(files, configInfo, fileCount) {
        const status = runResult();
        let n = 0;
        for (const fileP of files) {
            ++n;
            const file = await fileP;
            const emitProgress = (elapsedTimeMs) => cfg.progress({
                type: 'ProgressFileComplete',
                fileNum: n,
                fileCount,
                filename: file.filename,
                elapsedTimeMs,
            });
            if (!file.text) {
                emitProgress();
                continue;
            }
            const p = processFile(file, configInfo);
            const { elapsedTimeMs } = await timer_1.measurePromise(p);
            emitProgress(elapsedTimeMs);
            const r = await p;
            status.files += 1;
            if (r.issues.length || r.errors) {
                status.filesWithIssues.add(file.filename);
                status.issues += r.issues.length;
                status.errors += r.errors;
            }
            status.errors += r.configErrors;
        }
        return status;
    }
    async function reportConfigurationErrors(config) {
        const errors = cspell.extractImportErrors(config);
        let count = 0;
        errors.forEach((ref) => {
            const key = ref.error.toString();
            if (configErrors.has(key))
                return;
            configErrors.add(key);
            count += 1;
            cfg.emitters.error('Configuration', ref.error);
        });
        const dictCollection = await cspell_lib_1.getDictionary(config);
        dictCollection.dictionaries.forEach((dict) => {
            var _a;
            const dictErrors = ((_a = dict.getErrors) === null || _a === void 0 ? void 0 : _a.call(dict)) || [];
            const msg = `Dictionary Error with (${dict.name})`;
            dictErrors.forEach((error) => {
                const key = msg + error.toString();
                if (configErrors.has(key))
                    return;
                configErrors.add(key);
                count += 1;
                cfg.emitters.error(msg, error);
            });
        });
        return count;
    }
    function countConfigErrors(configInfo) {
        return reportConfigurationErrors(configInfo.config);
    }
    async function run() {
        header();
        const configInfo = await readConfig(cfg.configFile);
        cfg.info(`Config Files Found:\n    ${configInfo.source}\n`, emitters_1.MessageTypes.Info);
        const configErrors = await countConfigErrors(configInfo);
        if (configErrors)
            return runResult({ errors: configErrors });
        // Get Exclusions from the config files.
        const { root } = cfg;
        const globOptions = { root, cwd: root, ignore: configInfo.config.ignorePaths };
        const exclusionGlobs = glob_1.extractGlobExcludesFromConfig(root, configInfo.source, configInfo.config).concat(cfg.excludes);
        const files = filterFiles(await findFiles(cfg.files, globOptions), exclusionGlobs);
        return processFiles(fileLoader(files), configInfo, files.length);
    }
    function header() {
        cfg.info(`
cspell;
Date: ${new Date().toUTCString()}
Options:
    verbose:   ${yesNo(!!cfg.options.verbose)}
    config:    ${cfg.configFile || 'default'}
    exclude:   ${glob_1.extractPatterns(cfg.excludes)
            .map((a) => a.glob)
            .join('\n             ')}
    files:     ${cfg.files}
    wordsOnly: ${yesNo(!!cfg.options.wordsOnly)}
    unique:    ${yesNo(!!cfg.options.unique)}
`, emitters_1.MessageTypes.Info);
    }
    function isExcluded(filename, globs) {
        const { root } = cfg;
        const absFilename = path.resolve(root, filename);
        for (const glob of globs) {
            const m = glob.matcher.matchEx(absFilename);
            if (m.matched) {
                cfg.info(`Excluded File: ${path.relative(root, absFilename)}; Excluded by ${m.glob} from ${glob.source}`, emitters_1.MessageTypes.Info);
                return true;
            }
        }
        return false;
    }
    function filterFiles(files, excludeGlobs) {
        const excludeInfo = glob_1.extractPatterns(excludeGlobs).map((g) => `Glob: ${g.glob} from ${g.source}`);
        cfg.info(`Exclusion Globs: \n    ${excludeInfo.join('\n    ')}\n`, emitters_1.MessageTypes.Info);
        const result = files.filter(util.uniqueFn()).filter((filename) => !isExcluded(filename, excludeGlobs));
        return result;
    }
}
async function readConfig(configFile) {
    var _a;
    if (configFile) {
        const config = (await cspell.loadConfig(configFile)) || {};
        return { source: configFile, config };
    }
    const config = await cspell.searchForConfig();
    return { source: ((_a = config === null || config === void 0 ? void 0 : config.__importRef) === null || _a === void 0 ? void 0 : _a.filename) || 'not found', config: config || {} };
}
function runResult(init = {}) {
    const { files = 0, filesWithIssues = new Set(), issues = 0, errors = 0 } = init;
    return { files, filesWithIssues, issues, errors };
}
async function trace(words, options) {
    const configFile = await readConfig(options.config);
    const config = cspell.mergeSettings(cspell.getDefaultSettings(), cspell.getGlobalSettings(), configFile.config);
    const results = await cspell_lib_1.traceWords(words, config);
    return results;
}
exports.trace = trace;
async function checkText(filename, options) {
    const pSettings = readConfig(options.config);
    const [foundSettings, text] = await Promise.all([pSettings, readFile(filename)]);
    const settingsFromCommandLine = util.clean({
        languageId: options.languageId || undefined,
        local: options.local || undefined,
    });
    const info = calcFinalConfigInfo(foundSettings, settingsFromCommandLine, filename, text);
    return cspell.checkText(text, info.configInfo.config);
}
exports.checkText = checkText;
function createInit() {
    return Promise.reject();
}
exports.createInit = createInit;
function readFileInfo(filename, encoding = UTF8) {
    const pText = filename === STDIN ? get_stdin_1.default() : fsp.readFile(filename, encoding);
    return pText.then((text) => ({ text, filename }), (error) => {
        return error.code === 'EISDIR'
            ? Promise.resolve({ text: '', filename })
            : Promise.reject({
                ...error,
                message: `Error reading file: "${filename}"`,
            });
    });
}
function readFile(filename, encoding = UTF8) {
    return readFileInfo(filename, encoding).then((info) => info.text);
}
/**
 * Looks for matching glob patterns or stdin
 * @param globPatterns patterns or stdin
 */
async function findFiles(globPatterns, options) {
    const globPats = globPatterns.filter((filename) => filename !== STDIN);
    const stdin = globPats.length < globPatterns.length ? [STDIN] : [];
    const globResults = globPats.length ? await glob_1.globP(globPats, options) : [];
    const cwd = options.cwd || process.cwd();
    return stdin.concat(globResults.map((filename) => path.resolve(cwd, filename)));
}
function calcFinalConfigInfo(configInfo, settingsFromCommandLine, filename, text) {
    const ext = path.extname(filename);
    const fileSettings = cspell.calcOverrideSettings(configInfo.config, path.resolve(filename));
    const settings = cspell.mergeSettings(cspell.getDefaultSettings(), cspell.getGlobalSettings(), fileSettings, settingsFromCommandLine);
    const languageIds = settings.languageId ? [settings.languageId] : cspell.getLanguagesForExt(ext);
    const config = cspell.constructSettingsForText(settings, text, languageIds);
    return {
        configInfo: { ...configInfo, config },
        filename,
        text,
        languageIds,
    };
}
function extractContext(tdo, contextRange) {
    const { line, offset } = tdo;
    const textOffsetInLine = offset - line.offset;
    let left = Math.max(textOffsetInLine - contextRange, 0);
    let right = Math.min(line.text.length, textOffsetInLine + contextRange + tdo.text.length);
    const lineText = line.text;
    const isLetter = /^[a-z]$/i;
    const isSpace = /^\s$/;
    for (let n = contextRange / 2; n > 0 && left > 0 && isLetter.test(lineText[left - 1]); n--, left--) {
        /* do nothing */
    }
    for (let n = contextRange / 2; n > 0 && right < lineText.length && isLetter.test(lineText[right]); n--, right++) {
        /* do nothing */
    }
    // remove leading space
    for (; left < textOffsetInLine && isSpace.test(lineText[left]); left++) {
        /* do nothing */
    }
    const context = {
        text: line.text.slice(left, right).trimEnd(),
        offset: left + line.offset,
    };
    return context;
}
function yesNo(value) {
    return value ? 'Yes' : 'No';
}
exports._testing_ = {
    findFiles,
};
//# sourceMappingURL=application.js.map