"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractGlobExcludesFromConfig = exports.calcExcludeGlobInfo = exports._testing_ = exports.extractPatterns = exports.calcGlobs = exports.globP = void 0;
const glob_1 = __importDefault(require("glob"));
const path = __importStar(require("path"));
const fsp = __importStar(require("fs-extra"));
const cspell_glob_1 = require("cspell-glob");
const defaultExcludeGlobs = ['node_modules/**'];
/**
 * Attempt to normalize a pattern based upon the root.
 * If the pattern is absolute, check to see if it exists and adjust the root, otherwise it is assumed to be based upon the current root.
 * If the pattern starts with a relative path, adjust the root to match.
 * The challenge is with the patterns that begin with `/`. Is is an absolute path or relative pattern?
 * @param pat glob pattern
 * @param root absolute path | empty
 * @returns the adjusted root and pattern.
 */
function normalizePattern(pat, root) {
    // Absolute pattern
    if (path.isAbsolute(pat)) {
        const dir = findBaseDir(pat);
        if (dir.length > 1 && exists(dir)) {
            // Assume it is an absolute path
            return {
                pattern: pat,
                root: path.sep,
            };
        }
    }
    // normal pattern
    if (!/^\.\./.test(pat)) {
        return {
            pattern: pat,
            root,
        };
    }
    // relative pattern
    pat = path.sep === '\\' ? pat.replace(/\\/g, '/') : pat;
    const patParts = pat.split('/');
    const rootParts = root.split(path.sep);
    let i = 0;
    for (; i < patParts.length && patParts[i] === '..'; ++i) {
        rootParts.pop();
    }
    return {
        pattern: patParts.slice(i).join('/'),
        root: rootParts.join(path.sep),
    };
}
async function globP(pattern, options) {
    const root = (options === null || options === void 0 ? void 0 : options.root) || process.cwd();
    const opts = options || {};
    const rawPatterns = typeof pattern === 'string' ? [pattern] : pattern;
    const normPatterns = rawPatterns.map((pat) => normalizePattern(pat, root));
    const globPState = {
        options: { ...opts },
    };
    const globResults = normPatterns.map(async (pat) => {
        globPState.options = { ...opts, root: pat.root, cwd: pat.root };
        const absolutePaths = (await _globP(pat.pattern, globPState)).map((filename) => path.resolve(pat.root, filename));
        const relativeToRoot = absolutePaths.map((absFilename) => path.relative(root, absFilename));
        return relativeToRoot;
    });
    const results = (await Promise.all(globResults)).reduce((prev, next) => prev.concat(next), []);
    return results;
}
exports.globP = globP;
function _globP(pattern, state) {
    if (!pattern) {
        return Promise.resolve([]);
    }
    return new Promise((resolve, reject) => {
        const cb = (err, matches) => {
            if (err) {
                reject(err);
            }
            resolve(matches);
        };
        const options = state.glob ? { ...state.glob, ...state.options } : state.options;
        state.glob = glob_1.default(pattern, options, cb);
    });
}
function findBaseDir(pat) {
    const globChars = /[*@()?|[\]{},]/;
    while (globChars.test(pat)) {
        pat = path.dirname(pat);
    }
    return pat;
}
function exists(filename) {
    try {
        fsp.accessSync(filename);
    }
    catch (e) {
        return false;
    }
    return true;
}
function calcGlobs(commandLineExclude) {
    const globs = (commandLineExclude || [])
        .map((glob) => glob.split(/(?<!\\)\s+/g))
        .map((globs) => globs.map((g) => g.replace(/\\ /g, ' ')))
        .reduce((s, globs) => {
        globs.forEach((g) => s.add(g));
        return s;
    }, new Set());
    const commandLineExcludes = {
        globs: [...globs],
        source: 'arguments',
    };
    const defaultExcludes = {
        globs: defaultExcludeGlobs,
        source: 'default',
    };
    return commandLineExcludes.globs.length ? commandLineExcludes : defaultExcludes;
}
exports.calcGlobs = calcGlobs;
function extractPatterns(globs) {
    const r = globs.reduce((info, g) => {
        const source = g.source;
        const patterns = typeof g.matcher.patterns === 'string' ? [g.matcher.patterns] : g.matcher.patterns;
        return info.concat(patterns.map((glob) => ({ glob, source })));
    }, []);
    return r;
}
exports.extractPatterns = extractPatterns;
exports._testing_ = {
    normalizePattern,
};
function calcExcludeGlobInfo(root, commandLineExclude) {
    commandLineExclude = typeof commandLineExclude === 'string' ? [commandLineExclude] : commandLineExclude;
    const choice = calcGlobs(commandLineExclude);
    const matcher = new cspell_glob_1.GlobMatcher(choice.globs, root);
    return [
        {
            matcher,
            source: choice.source,
        },
    ];
}
exports.calcExcludeGlobInfo = calcExcludeGlobInfo;
function extractGlobExcludesFromConfig(root, source, config) {
    if (!config.ignorePaths || !config.ignorePaths.length) {
        return [];
    }
    const matcher = new cspell_glob_1.GlobMatcher(config.ignorePaths, root);
    return [{ source, matcher }];
}
exports.extractGlobExcludesFromConfig = extractGlobExcludesFromConfig;
//# sourceMappingURL=glob.js.map