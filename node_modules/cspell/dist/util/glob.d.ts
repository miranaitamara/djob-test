import { IOptions } from './IOptions';
import { GlobMatcher } from 'cspell-glob';
import * as cspell from 'cspell-lib';
export interface GlobOptions extends IOptions {
    cwd?: string;
    root?: string;
}
/**
 * Attempt to normalize a pattern based upon the root.
 * If the pattern is absolute, check to see if it exists and adjust the root, otherwise it is assumed to be based upon the current root.
 * If the pattern starts with a relative path, adjust the root to match.
 * The challenge is with the patterns that begin with `/`. Is is an absolute path or relative pattern?
 * @param pat glob pattern
 * @param root absolute path | empty
 * @returns the adjusted root and pattern.
 */
declare function normalizePattern(pat: string, root: string): PatternRoot;
export declare function globP(pattern: string | string[], options?: GlobOptions): Promise<string[]>;
interface PatternRoot {
    pattern: string;
    root: string;
}
export declare function calcGlobs(commandLineExclude: string[] | undefined): {
    globs: string[];
    source: string;
};
export interface GlobSrcInfo {
    matcher: GlobMatcher;
    source: string;
}
interface ExtractPatternResult {
    glob: string;
    source: string;
}
export declare function extractPatterns(globs: GlobSrcInfo[]): ExtractPatternResult[];
export declare const _testing_: {
    normalizePattern: typeof normalizePattern;
};
export declare function calcExcludeGlobInfo(root: string, commandLineExclude: string[] | string | undefined): GlobSrcInfo[];
export declare function extractGlobExcludesFromConfig(root: string, source: string, config: cspell.CSpellUserSettings): GlobSrcInfo[];
export {};
